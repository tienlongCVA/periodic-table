<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" type="image/jpg" href="img/images.jpg"/>
  <title>Mô hình 3D Nguyên Tố</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; color: white; font-family: Arial; }
    #info {
      position: absolute;
      top: 20px; left: 20px;
      background: rgba(20,20,20,0.7);
      padding: 12px 16px;
      border-radius: 10px;
      border: 1px solid #444;
      box-shadow: 0 0 12px rgba(0,255,255,0.5);
      width: 240px;
    }
    #info h2 { margin: 0 0 8px; font-size: 20px; color: #00ffff; text-align: center; }

    /* Nút quay lại */
    #exitBtn {
      position: absolute; top: 20px; right: 20px;
      padding: 10px 16px;
      border: none; border-radius: 8px;
      background: rgba(255,50,50,0.8);
      color: white; font-size: 14px; font-weight: bold;
      cursor: pointer; box-shadow: 0 0 10px rgba(255,0,0,0.7);
      transition: 0.2s;
    }
    #exitBtn:hover { background: rgba(255,0,0,1); transform: scale(1.05); }

    /* Nút tạm dừng / tiếp tục */
    #toggleBtn {
      position: absolute; top: 70px; right: 20px;
      padding: 10px 16px;
      border: none; border-radius: 8px;
      background: rgba(50,150,255,0.8);
      color: white; font-size: 14px; font-weight: bold;
      cursor: pointer; box-shadow: 0 0 10px rgba(0,150,255,0.7);
      transition: 0.2s;
    }
    #toggleBtn:hover { background: rgba(0,150,255,1); transform: scale(1.05); }
  </style>
</head>
<body>
  <div id="info"></div>
  <button id="exitBtn" onclick="window.location.href='index.html'">⏎ Quay lại</button>
  <button id="toggleBtn" onclick="toggleAnimation()">⏸ Tạm dừng</button>

  <!-- Thư viện Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

  <script>
    const params = new URLSearchParams(window.location.search);
    const name = params.get("name") || "Hydrogen";
    const number = parseInt(params.get("number")) || 1;
    const mass = params.get("mass") || "?";

   // --- Tải dữ liệu từ file JSON ---
fetch("elements.json")
  .then(res => res.json())
  .then(data => {
    const element = data[name];

    if (element) {
      document.getElementById("info").innerHTML = `
        <h2>${name} (${element.symbol})</h2>
        <p><b>Số hiệu nguyên tử:</b> ${element.atomicNumber}</p>
        <p><b>Điện tích hạt nhân</b> +${element.atomicNumber}</p>
        <p><b>Nguyên tử khối:</b> ${element.atomicMass}</p>
        <p><b>Người phát hiện:</b> ${element.discoverer}</p>
        <p><b>Nhiệt độ nóng chảy:</b> ${element.meltingPoint}</p>
        <p><b>Nhiệt độ sôi:</b> ${element.boilingPoint}</p>
        <p><b>Ứng dụng:</b> ${element.applications}</p>
        <p><b>Thông tin thú vị:</b> ${element.funFact}</p>
      `;
    } else {
      document.getElementById("info").innerHTML = `
        <h2>${name}</h2>
        <p><b>Không tìm thấy thông tin chi tiết trong cơ sở dữ liệu.</b></p>
      `;
    }

    // Sau khi load xong dữ liệu, khởi tạo mô hình 3D
    initModel();
  })
  .catch(err => {
    console.error("Lỗi khi tải elements.json:", err);
    document.getElementById("info").innerHTML = `
      <h2>${name}</h2>
      <p><b>Không tải được dữ liệu nguyên tố.</b></p>
    `;
    initModel();
  });


    let electronConfig = {};
    let isPaused = false;

    function toggleAnimation() {
      isPaused = !isPaused;
      document.getElementById("toggleBtn").innerText = isPaused ? "▶ Tiếp tục" : "⏸ Tạm dừng";
    }

    fetch("electron_config.json")
      .then(res => res.json())
      .then(data => { electronConfig = data; initModel(); })
      .catch(() => initModel());

    function distributeElectrons(Z) {
      const shells = [];
      let remaining = Z;
      const capacities = [2, 8, 18, 32];
      for (let i = 0; i < capacities.length && remaining > 0; i++) {
        let count = Math.min(remaining, capacities[i]);
        shells.push(count);
        remaining -= count;
      }
      return shells;
    }

    function initModel() {
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040, 2));
      const light = new THREE.PointLight(0xffffff, 1.5, 100);
      light.position.set(5, 5, 5);
      scene.add(light);

      const atomGroup = new THREE.Group();
      scene.add(atomGroup);

      // Hạt nhân
      const nucleus = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 32, 32),
        new THREE.MeshPhongMaterial({ color: 0xff3333, emissive: 0xaa0000, shininess: 100 })
      );
      atomGroup.add(nucleus);


      // Electron
      const eGeo = new THREE.SphereGeometry(0.12, 16, 16);
      const eMat = new THREE.MeshPhongMaterial({ color: 0x33aaff, emissive: 0x0088ff, shininess: 150 });
      const electrons = [];
      const electronShells = electronConfig[name] || distributeElectrons(number);

      function createOrbit(radius) {
        const curve = new THREE.EllipseCurve(0, 0, radius, radius);
        const points = curve.getPoints(200);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x8888ff, transparent: true, opacity: 0.25 });
        const orbit = new THREE.LineLoop(geometry, material);
        orbit.rotation.x = Math.PI / 2;
        atomGroup.add(orbit);
      }

      electronShells.forEach((count, shellIndex) => {
        const radius = 1.5 + shellIndex * 1.2;
        createOrbit(radius);
        for (let i = 0; i < count; i++) {
          const e = new THREE.Mesh(eGeo, eMat);
          e.userData = { radius, angle: i * (2 * Math.PI / count), speed: 0.02 };
          electrons.push(e);
          atomGroup.add(e);
        }
      });

      // Nền sao
      const starGeo = new THREE.BufferGeometry();
      const starCount = 2000;
      const pos = [];
      for (let i = 0; i < starCount; i++) {
        pos.push((Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200);
      }
      starGeo.setAttribute("position", new THREE.Float32BufferAttribute(pos, 3));
      const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.3 });
      scene.add(new THREE.Points(starGeo, starMat));

      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      camera.position.z = 6;

      function animate() {
        requestAnimationFrame(animate);

        if (!isPaused) {
          electrons.forEach(e => {
            e.userData.angle += e.userData.speed;
            e.position.x = e.userData.radius * Math.cos(e.userData.angle);
            e.position.z = e.userData.radius * Math.sin(e.userData.angle);
          });

          atomGroup.rotation.y += 0.002;
        }

        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }
  </script>
</body>
</html>
